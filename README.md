# 原型继承调研报告

## 什么是原型继承
原型继承(Prototypal Inheritance)是“基于原型的编程方式”(Prototype-based Programming)的具体实施方法。其特征为：通过利用重复使用已存在的对象(object)，而不是已存在的类，来实现已有性质的复用。

## 基于原型的语言的特点
这种语言的对象都可以归结为一种类型，它具有属性(attribute)和方法(method)。

这种语言为创建对象提供了三种原语(primitive)：创建一个新对象、根据一个已有的对象克隆出一个新对象、扩展一个对象。

**设计理念**

有原型继承特性的不同语言，可能出于不同的设计理念，大概有如下的几种考虑：

- 原型继承能够提供对对象的更方便的描述。人们描述客观事物时，一般都是先从描述简单的实际事物开始，之后才会形成一类事物的抽象描述。而类继承让人们不得不从反方向去思考。
- 基于原型的编程模型，为程序员提供了更为简单的使用方式，如更少的概念和原语数量(只有三个)。它避免了类似类的实例化的过程。通过扩展操作得到一个新对象，远比继承一个类，再实例化新的对象这两步要简单。
- 
## 原型继承思想的来源

not finished yet.

---

在构建更大、更复杂、可复用需求更强烈的软件时，封装和隐藏是必不可少的。换句话说，要对程序组件的构成和行为予以约束，以利于软件各部分的解耦和复用。比如在某种图形界面桌面程序中，各个界面元素（如壁纸和图标）都能响应“鼠标点击”事件，这是它们所共享的**接口**，但它们对这个接口的实现是不同的。对于桌面上的所有图标，它们可能会有完全相同的内部数据结构，以及完全相同的“鼠标点击”接口实现，它们是同一种**类型**。如果这个程序要新增一种特殊的文件夹图标，它和原来的普通图标行为相似（都有同样的排版逻辑、都要显示一个小图案），但具体行为上又有所区别。最方便的方法是**复用**原来的普通图标的部分代码，减少重复劳动并确保多数行为一致。各种高级编程语言中的思想无非是为了对上述情况进行建模。

在面向类的思想中，接口可以通过一个虚拟基类来单独声明，这种情况下要实现接口就需要进行一次继承，也可以直接在某个类的方法中体现出来。接口的实现属于类，既可以通过将类实例化为对象来复用接口的实现（所有产生出来的对象都共享了同一套接口实现），也可以通过从父类继承出子类来对接口的实现加以修改地复用。

这种思路将各种不同的概念混合在一起处理，有时会产生一些混乱——首先，它不区分接口和类型，而是一律用“类”来表示，因此如果想继承一个类型的同时实现一种新的接口，就必须进行多重继承，此时两种不同的概念在语法层面看起来是相同的。其次，父类的代码通过继承变成子类的代码，又通过实例化变成真正的对象的代码，这两个相似的过程在语法层面看起来又截然不同。因此，想要直接使用面向类的思想是比较困难和反直觉的，需要按照一定的设计模式来活用其“类”的概念才能方便。

我个人认为函数式思想和面向原型思想似乎恰好体现了改善上述问题的两个方向。前者是明确地分离了接口和类型的概念，精确地建立了模型。后者则是模糊了类型和实例的界限，又用鸭子类型弱化了接口。

在面向原型思想中，一切皆为对象，不需要“类”的概念。对象就是一个键-值对集（JS的明明是个字典的object、Self的slots、Python的`__dict__`），其中键是符合特定规则的字符串，而值是其他的对象。语言本身没有显式的接口概念，特定的键就是约定俗成的接口。对代码的复用通过克隆对象来实现，也就是说一个对象在直接使用时，可以看作是面向类的思想中的“实例”，而用来克隆以创建新对象时，忽然又可以看作面向类的思想中的“类”了。如果它克隆出来的对象再次克隆以创建新对象，它此时看起来，则像一个父类在通过继承产生子类一样，将自己的代码传递给克隆体。这样的设计不再奇怪地区分“类”和“实例”，更加自然、灵活（当然也因类型不严格而更加危险），适合特定场景中快速开发程序。

还有一个值得一提的重点，就是代码在从一个地方传递到另一个地方时，“深复制”和“浅复制”是有区别的。我们一般想要的都是浅复制，即并不真正拷贝代码，而是新生成的对象的名字空间中如果缺失某条目，就去其模板（所属的类或父类）中找。这样既能节约空间，也能更好地维护统一性（以防忘了将某个副本随主本一起修改）。但在追求灵活的特定场合，我们可能希望有深复制的效果，以确保新生成的对象和其模板完全脱离关系。这两种不同的行为非常容易共存。为了保持语法层面的统一性，一般在实现面向原型思想时，各个对象的名字空间都是独立的，用一个特殊的键（如JS中的`__proto__`，Self中的`parent`，Python中的`__class__`或`__bases__`）指向其原型，作为没找到键时下一个查找的名字空间。如此一路链接下去，会产生一条原型链，类似于面向类的思想中的继承链。

那么，面向原型思想怎样实现多重继承呢？毕竟总有一些时候我们希望混合两个已有的模板。一般有两种解决这个问题的方法，一种是允许原型链分叉，并且规定遇到分叉甚至菱形继承时的处理方法。如Python的`__bases__`是一个可以有任意项的元组，语言规定在沿着原型链寻找属性时，按照深度优先搜索，每个名字空间最多被访问一次。另一种是不许原型链分叉，这样非常简单，如JS的`__proto__`直接指向原型，没有分叉的可能性。在这种情况下，多重继承只能取其中一个模板作为原型，其他模板要用上述“深复制”的方法直接拷贝到新生成的对象的名字空间内部。JS的extends机制正是这样实现的。
