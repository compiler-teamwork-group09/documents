# 原型继承调研报告

在面向对象编程语言中，为了提高复用性，多继承几乎是不可避免的行为。

例如，当我们分别定义表示整数、列表、集合这三种类时，会发现不同的类需要不同的特性。我们会将这些特性均以接口的方式呈现，比如Int类会具有可比较、可相加这两个接口，而List类会具有元素可比较、元素可相加、可插入元素这三个接口，Set类会具有可相加、可插入元素这两个接口。故当一个类具有多个特性时，需要该类继承这多个接口类。故多继承是不可避免的。

而多继承所带来的典型问题如图所示：
![diamond_inheritane](diamond_inheritance.png)
即同一个父类A内的成员`var`在子类D内出现了多次，同时B类和C类中都复写了该成员。当出现`D.var`时，编译器将不知道应该调用B类中的`var`还是C类中的`var`。

此问题的解决办法有多种。其中一种方法是：在子类里不直接拷贝父类的成员，而只是保留对父类的引用。

## 什么是原型继承
原型继承(Prototypal Inheritance)是“基于原型的编程方式”(Prototype-based Programming)的具体实施方法。其特征为：通过利用重复使用已存在的对象(object)，而不是已存在的类，来实现已有性质的复用。

**基于原型的语言的设计理念**

有原型继承特性的不同语言，可能会出于不同的设计理念，大概有如下的几种考虑：

- 对于使用者而言，原型继承能够提供对对象的更方便的、更符合人们习惯的描述方式。人们描述客观事物时，一般都是先从描述简单的实际事物开始，之后才会形成一类事物的抽象描述。而类继承让人们不得不从反方向去思考。
- 基于原型的编程模型，为程序员提供了更为简单的使用方式，如更少的概念和原语数量(只有三个)。它避免了类似类的实例化的过程。通过扩展操作得到一个新对象，远比继承一个类，再实例化新的对象这两步要简单。

## 面向原型语言的特点
- 这种语言的对象大多都可以归结为一种记录类型，该类型具有属性(attribute)和方法(method)。

- 这种语言为创建对象提供了两种方式：凭空创建一个新对象、根据一个已有的对象克隆并扩展(也可不扩展)从而得到一个新对象。

- 几乎所有面向原型的语言都是解释性的、动态类型的语言。

- 原型继承语言按继承方式可分为两种：采用`Delegation`继承方式的语言与采用`Concatenation`继承方式的语言。

  其中`Delegation`是指在访问对象的成员时，允许在找不到该成员时再到其父对象的上下文中去查找该成员，这就使得克隆/继承而来的对象不必为已有的属性重新分配存储空间，而只需保留对父对象的引用，这种克隆也叫[浅拷贝](https://en.wikipedia.org/wiki/Object_copying#Shallow_copy)。

  而`Concatenation`继承方式，在克隆新对象时，会将父对象的属性全部拷贝过来，从新对象中看不到对父对象的引用。，这种克隆也叫[深拷贝](https://en.wikipedia.org/wiki/Object_copying#Deep_copy)。

  我们一般想要的都是`Delegation`继承方式，这样既能节约空间，也能更好地维护统一性（以防忘了将某个副本随主本一起修改）。但在追求灵活的特定场合，我们可能希望有深复制的效果，以确保新生成的对象和其模板完全脱离关系。这两种不同的行为非常容易共存(如在下面要介绍的Act I语言中)。为了保持语法层面的统一性，一般在实现面向原型思想时，各个对象的名字空间都是独立的，用一个特殊的键（如JS中的`__proto__`，Self中的`parent`，Python中的`__class__`或`__bases__`，下文会有涉及）指向其原型，作为没找到键时下一个查找的名字空间。如此一路链接下去，会产生一条原型链，类似于面向类的思想中的继承链。


## 原型继承在各语言中的体现

### Frame Theory & Act I
原型继承思想的雏形可以追溯到古老的Frame理论和Act I语言。

**Frame Theory**

Frame理论描述了这样一种类型(称作Frame):
- 每个Frame由一组属性构成。而一个属性表示为“属性名”以及一到多个值。
- 可以通过陈述与一个已知Frame的区别，来定义一个新Frame。
    新Frame的`is-a`属性用来指向之前已存在的Frame。

基于Frame理论的语言有[KRL](https://en.wikipedia.org/wiki/KRL_(programming_language)), FRL(Frame Representation Language)。它们都只是知识表示语言(Knowledge Representation Language)，而不是编程语言，不涉及对象的存储机制。

**Act I**

Frame理论只是提出了对象逻辑上的关系与表示，而古老的[Act 1](www.ai.sri.com/~cypress/tucson/node7.html)语言已经涉及到对象如何拷贝，如何被扩展等原型继承语言的基本特征。

  Act 1语言中的对象称为Actor,可以包含属性(attributes)和行为(behaviours，或视为方法)。Actor可通过克隆已有的对象，根据已有的对象创建新对象，和扩展已有的对象来创建。这对应该语言的三个原语`create`，`extend`，`c-extend`。

  - `create`操作可以将已有的一个对象完全拷贝一份作为一新对象，并可以再加上新的属性。新的对象的原属性可以具有与原来对象不同的值。

    示例代码如下：
    ```c
    (point `create `point2
      `((x 3) (y 30))
      `((move (lambda (newX newY) // create new function
          (setq x newX y newY)))))
    ```

  - `extend`操作以一个已存在对象创建新对象(也可以凭空创建新对象，这个时候原对象为`Object`)。在创建新对象后，并不拷贝所有的属性，而是创建一个对原对象的引用。对于已有的属性，新对象将通过该引用询问原对象来查找该属性。
  
    示例代码如下：
    ```c
    (point2 `extend `turtle
      `((heading 0) (y 4))
      `((forward (lambda (...)
          ...))))
    ```

  由`create`和`extend`所指出的新旧对象之间的关系，都可以认为是继承关系。故Act I语言提供了对象间继承的两种典型的方式，它们分别是通过[浅拷贝](https://en.wikipedia.org/wiki/Object_copying#Shallow_copy)和[深拷贝](https://en.wikipedia.org/wiki/Object_copying#Deep_copy)来完成的。由以上示例代码所创建的对象的存储结构及引用关系见下图，其中Point2是由Point深拷贝继承而来,而turtle是由Point2浅拷贝继承而来。
  ![act1_demo](act1_language.png)

### JavaScript
JavaScript为典型的基于原型的语言，在该语言里没有类的概念。

- 创建一个新对象
  ```javascript
  var foo = {a: 1, b: 2};
  ```
- 根据一个已有的对象克隆出一个新对象

  可以以某个对象为原型创建出新对象：
  ```javascript
  var bar = Object.create(foo);
  bar.a = 0;
  bar.c = 3;
  ```

  可先定义子对象后，再将其原型设为某个对象:
  ```javascript
  var bar = {a: 0, c: 3};
  Object.setPrototypeOf(bar, foo);
  ```
JavaScript同样采用`Concatenation`的继承方式。
### Python
从形式上来讲，Python仍为一使用类的语言。但由于Python的类是可以在运行时创建，故类也是一个对象，并且可以动态扩展类的成员，故Python也可以认为是有原型的特性。但是，Python里由类实例化的对象在默认情况下并不能再继承出对象，故Python不能算是严格的原型继承语言。

尽管如此，组员安鸣霄还是实现了一套Python的类型系统，从形式上实现了完全的原型继承。可通过该类型系统提供的接口方便地从原对象创建出新对象，而不需要自己创建类。详见[**python3-proto** project](https://github.com/compiler-teamwork-group09/python3-proto)。

王子博实现的另一种短小精悍的Python原型继承代码如下：
```python
class object:

	def __init__(self):
		self.__parent__ = type(self)

	def __call__(self):
		obj = type(self)()
		obj.__parent__ = self
		return obj

	def __getattr__(self, name):
		return getattr(self.__parent__, name)

```

使用示例代码如下：
```python
a = object()
a.foo = 1
a.bar = 2
b = a()
b.foo # -> 1
b.bar = 3
b.bar # -> 3
a.bar # -> 2
a.foo = 4
b.foo # -> 4
c = b()
c.bar # -> 3
```
使用时，利用object类来创建对象。由object类创建的对象`a`,`b`,`c`具有成员方法`__call__()`，将会在执行`a()`和`b()`时被调用，并返回由该对象的类型实例化而得到的对象。

该原型继承采用了Delegation的继承方式。即在访问成员时，若在当前对象(`self`)未找到该成员，则从其父对象(`self.__parent__`)继续寻找。

## 面向原型思想的多重继承实现

使用原型继承，注定了每次创建新对象时，其父对象只有一个，但有些时候我们确实希望某个类能够拥有多个类的特性。

一般有两种解决这个问题的方法，一种是允许原型链分叉，并且规定遇到分叉甚至菱形继承时的处理方法。如Python的`__bases__`是一个可以有任意项的元组，语言规定在沿着原型链寻找属性时，按照深度优先搜索，每个名字空间最多被访问一次。


<!---

在构建更大、更复杂、可复用需求更强烈的软件时，封装和隐藏是必不可少的。换句话说，要对程序组件的构成和行为予以约束，以利于软件各部分的解耦和复用。在高级语言中，多是通过面向对象的概念来达到这个目的。



比如在某种图形界面桌面程序中，各个界面元素（如各个图标、按钮等不同类型）都是由对应的不同类实例化而来的。而即使是不同类型的组件，也需要相同和不同。都能响应“鼠标点击”事件，这是它们所共享的**接口**，但它们对这个接口的实现是不同的。对于桌面上的所有图标，它们可能会有完全相同的内部数据结构，以及完全相同的“鼠标点击”接口实现，它们是同一种**类型**。如果这个程序要新增一种特殊的文件夹图标，它和原来的普通图标行为相似（都有同样的排版逻辑、都要显示一个小图案），但具体行为上又有所区别。最方便的方法是**复用**原来的普通图标的部分代码，减少重复劳动并确保多数行为一致。各种高级编程语言中的思想无非是为了对上述情况进行建模。



在面向类的思想中，接口可以通过一个虚拟基类来单独声明，这种情况下要实现接口就需要进行一次继承，也可以直接在某个类的方法中体现出来。接口的实现属于类，既可以通过将类实例化为对象来复用接口的实现（所有产生出来的对象都共享了同一套接口实现），也可以通过从父类继承出子类来对接口的实现加以修改地复用。

这种思路将各种不同的概念混合在一起处理，有时会产生一些混乱——首先，它不区分接口和类型，而是一律用“类”来表示，因此如果想继承一个类型的同时实现一种新的接口，就必须进行多重继承，此时两种不同的概念在语法层面看起来是相同的。其次，父类的代码通过继承变成子类的代码，又通过实例化变成真正的对象的代码，这两个相似的过程在语法层面看起来又截然不同。因此，想要直接使用面向类的思想是比较困难和反直觉的，需要按照一定的设计模式来活用其“类”的概念才能方便。

我个人认为函数式思想和面向原型思想似乎恰好体现了改善上述问题的两个方向。前者是明确地分离了接口和类型的概念，精确地建立了模型。后者则是模糊了类型和实例的界限，又用鸭子类型弱化了接口。

在面向原型思想中，一切皆为对象，不需要“类”的概念。对象就是一个键-值对集（JS的明明是个字典的object、Self的slots、Python的`__dict__`），其中键是符合特定规则的字符串，而值是其他的对象。语言本身没有显式的接口概念，特定的键就是约定俗成的接口。对代码的复用通过克隆对象来实现，也就是说一个对象在直接使用时，可以看作是面向类的思想中的“实例”，而用来克隆以创建新对象时，忽然又可以看作面向类的思想中的“类”了。如果它克隆出来的对象再次克隆以创建新对象，它此时看起来，则像一个父类在通过继承产生子类一样，将自己的代码传递给克隆体。这样的设计不再奇怪地区分“类”和“实例”，更加自然、灵活（当然也因类型不严格而更加危险），适合特定场景中快速开发程序。

还有一个值得一提的重点，就是代码在从一个地方传递到另一个地方时，“深复制”和“浅复制”是有区别的。我们一般想要的都是浅复制，即并不真正拷贝代码，而是新生成的对象的名字空间中如果缺失某条目，就去其模板（所属的类或父类）中找。这样既能节约空间，也能更好地维护统一性（以防忘了将某个副本随主本一起修改）。但在追求灵活的特定场合，我们可能希望有深复制的效果，以确保新生成的对象和其模板完全脱离关系。这两种不同的行为非常容易共存。为了保持语法层面的统一性，一般在实现面向原型思想时，各个对象的名字空间都是独立的，用一个特殊的键（如JS中的`__proto__`，Self中的`parent`，Python中的`__class__`或`__bases__`）指向其原型，作为没找到键时下一个查找的名字空间。如此一路链接下去，会产生一条原型链，类似于面向类的思想中的继承链。

那么，面向原型思想怎样实现多重继承呢？毕竟总有一些时候我们希望混合两个已有的模板。一般有两种解决这个问题的方法，一种是允许原型链分叉，并且规定遇到分叉甚至菱形继承时的处理方法。如Python的`__bases__`是一个可以有任意项的元组，语言规定在沿着原型链寻找属性时，按照深度优先搜索，每个名字空间最多被访问一次。另一种是不许原型链分叉，这样非常简单，如JS的`__proto__`直接指向原型，没有分叉的可能性。在这种情况下，多重继承只能取其中一个模板作为原型，其他模板要用上述“深复制”的方法直接拷贝到新生成的对象的名字空间内部。JS的extends机制正是这样实现的。

## 参考资料
https://www.w3schools.com/js/js_object_prototypes.asp
-->
